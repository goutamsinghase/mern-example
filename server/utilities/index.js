'use strict';

module.exports = function(app) {

  const bcrypt = require('bcrypt');
  const generate = require('nanoid/generate');
  const Puid = require('puid');

  /**
   * utility namespace
   * 
   * @namespace utility
   *
   * @property {HandleFile}          handleFile instance of Ex File Handle Class
   * @property {DateHelper}          dateHelper instance of CustomDate Class
   * @property {Message}             message    instance of Message Class
   * @property {language.getMessage} getLang    acquiring client language 
   * @property {module:Workflow}     workflow   acquiring the workflow
   */
  var utility = {
    'async': require('async'),
    'dateHelper': require('./scripts/dateHelper'),
    'message': require('./scripts/message'),
    'localize': require('./scripts/localize')(app),
    'workflow': require('./scripts/workflow'),
    'apiValidate': require('./scripts/api-validate'),
    'jsonSchema': require('./scripts/json-schema')(app),
    'errorHandler': require('./scripts/errorHandler')(app), // attached as middleware in app
  };

  utility.generateOTP = function(length) {
    let otp = (Math.random() * Math.pow(10, length)).toFixed();
    if (otp.length < length) {
      otp += Array(length - otp.length).fill(0).join('');
    }
    return otp;
  };

  /**
   * Get Country Code 
   * @param  {String} countryCode The Country Code
   * @return {String}             Country Code
   * @memberOf utility
   */
  utility.getCountryCode = function(countryCode) {
    return app.config.countryCode.countryList[countryCode];
  };

  /**
   * generate a unique name
   * @return {String}             return a unique name generated by using puid library
   * @memberOf utility
   */
  utility.generateUniqueKey = function(isShort) {
    let puid = new Puid(isShort);
    return puid.generate();
  };

  /**
   * Executes mkdir -p "nested_folder_names" in the shell
   * @param  {String}   folderList The "/" separated nested folder names
   * @param  {Function} cb         The callback
   * NOTE: Requires ES6
   */
  utility.mkdirR = function(folderList, cb) {
    require('child_process').exec(`mkdir -p "${folderList}"`, {}, cb);
  };


  /**
   * this function generates a standard access control object
   * @param  {object}   res                         response object
   * @param  {Function} next                        next queued function                         
   * @return {utility.getCallbacksResponse}         return of this function
   *
   * @memberOf utility
   */
  utility.getCallbacks = function(res, next) {
    return {
      'allowed': next,
      'denied': function() {
        res.status(403);
        res.send();
      },
      'notfound': function() {
        res.status(404);
        res.send();
      },
      'invalid': function() {
        res.status(405);
        res.send();
      }
    };
  };


  /**
   * this function attaches the workflow instance to each request obejct and execute the next queued function
   * @param  {object}   req    request object 
   * @param  {object}   res    response object
   * @param  {Function} next   next queued function 
   * @memberOf utility
   */
  utility.attachWorkflow = function(req, res, next) {
    req.workflow = req.app.utility.workflow(req, res);
    next();
  };

  /**
   * this function generate the encrypted password over the set password
   * @param  {String}         password    password of the manager
   * @param {requestCallback} done        callback to be executed after the find operation
   * @function .encryptPassword
   * @memberOf utility
   */
  utility.encryptPassword = function(password, done) {
    if (done && typeof done === 'function') {
      bcrypt.genSalt(10, function(err, salt) {
        if (err) {
          return done(err);
        }

        bcrypt.hash(password, salt, function(err, hash) {
          done(err, hash);
        });
      });
    } else {
      return bcrypt.genSalt(10).then((salt) => bcrypt.hash(password, salt));
    }
  };

  /**
   * this function matches the password and return whether the password matches or not
   * @param  {String}          password    passowrd of the manager
   * @param  {String}          hash        encrypted passowrd
   * @param  {requestCallback} done        callback to be executed after the find operation
   * @function .validatePassword
   * @memberOf utility
   */
  utility.validatePassword = function(password, hash, done) {
    if (done && typeof done === 'function') {
      bcrypt.compare(password, hash, function(err, res) {
        done(err, res);
      });
    } else {
      return bcrypt.compare(password, hash);
    }
  };


  /**
   * This function parse the value and return the equivalent Boolean value
   * if the values are not satisfied condition it returns null
   * @param  {mixed}   value     the value that needs to be checked 
   * @return {null}              if the function does not find the equivalent Boolean
   * @return {true}              if the valus os true or 'true'
   * @return {false}             if the valus os false or 'false'
   */
  utility.checkBoolean = function(value) {
    switch (value) {
      case 1:
      case true:
      case '1':
      case 'true':
        return true;
      case 0:
      case false:
      case '0':
      case 'false':
        return false;
      default:
        return null;
    }
  };


  /**
   * Get random code
   * @param  {Number} length length of the random staring
   * @return {String}        random string
   */
  utility.getRandomCode = function(length, isPassword) {
    const codeString = 'ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz12345678';
    let output = '',
      index;

    if (!length) {
      length = 6;
    }
    for (var i = 0; i < length; i++) {
      index = Math.floor(Math.random() * codeString.length);

      if (index === 1) {
        index = index - 1;
      }
      output += codeString[index];
    }
    if (isPassword) {
      output = output + 'A1a';
    }
    return output;
  };

  /**
   * Get Unique Id by nanoid
   * @param  {Number} length Length of generated Id
   * @return {String}        Generated Id
   */
  utility.getNanoId = function(length) {
    return generate('0123456789abcdefghijklmnopqrstuvwxyzABCDEFGHIJKLMNOPQRSTUVWXYZ', length || 10).toUpperCase();
  };

  /**
   * check value is a mongoose id or not
   * @memberOf utility
   */
  utility.checkMongooseObjectId = function(value) {
    return value && value.toString().length === 24 && require('mongoose').Types.ObjectId.isValid(value);
  };

  utility.format = {
    user: function(userObj) {
      let newUserObj = JSON.parse(JSON.stringify(userObj));
      if (newUserObj.authenticationInfo) {
        delete newUserObj.authenticationInfo;
      }
      delete newUserObj.sessionInfo;
      return newUserObj;
    }
  };

  return utility;
};